# MiniMax refactoring

# Thinking Process (267.9 seconds)

Хорошо, мне нужно добавить красивый вывод в консоль для этого Python-скрипта. Давайте посмотрим на текущий код. Сейчас функция update_display просто очищает экран и выводит сырые данные из словаря indicators. Нужно сделать вывод более структурированным и визуально привлекательным.

Первое, что приходит в голову — использовать библиотеку для красивого вывода, например, colorama для цветного текста или rich для более продвинутых возможностей. Но, возможно, пользователь хочет минимальные изменения без дополнительных зависимостей. Посмотрю на текущий код: используется os.system('cls' или 'clear'), значит, очистка консоли есть. Нужно улучшить форматирование вывода.

Текущий вывод — это просто print с форматированием. Можно добавить разделение секций, цвета, выравнивание, возможно, использовать рамки или подзаголовки.

Также в коде есть показатели, которые обновляются. Хорошо бы показать время обновления более наглядно, например, подсветить, если данные устарели.

Сначала подумаю о структуре вывода. Сейчас после очистки экрана выводится текущее время и список кодов. Можно добавить заголовок, разделители, возможно, табличное представление.

Например, сделать заголовок с текущей датой и временем, затем таблицу с колонками: Код, Значение, Время обновления. Использовать выравнивание, чтобы всё выглядело аккуратно.

Также можно добавить цветовую индикацию. Например, если время elapsed превышает какое-то значение, подсвечивать его красным. Но для этого нужно использовать colorama, инициализировать её в начале.

Но если нельзя добавлять внешние библиотеки, то можно обойтись стандартными средствами. Хотя colorama обычно используется для кросс-платформенного цвета в консоли.

Допустим, разрешено использовать colorama. Тогда можно импортировать её, инициализировать и добавить цвета в вывод.

Также можно добавить анимацию или прогресс-бар, но это может быть излишним. Лучше сделать статичный, но структурированный вывод.

Ещё можно добавить разделение между обновлениями, например, линии из символов, чтобы визуально отделить разные секции.

Теперь посмотрю на текущий код функции update_display:

Она очищает экран, получает текущее время, сортирует коды и выводит их в цикле.

Нужно изменить print в цикле на более красивый формат. Например, использовать f-строки с выравниванием, добавить заголовки.

Можно сделать так:

Заголовок с текущей датой и временем.
Строка-разделитель.
Заголовки колонок: Код | Значение | Время (сек)
Затем для каждого кода выводить строку с выравненными значениями.
Также можно добавить сортировку кодов в более понятном порядке, если текущая сортировка (sorted(indicators)) выводит их в порядке ASCII, но, возможно, лучше сортировать по числовому значению кода.

Но в текущем коде коды хранятся как символы (symbol = chr(...)), и в словаре indicators ключи — это символы. Например, если code после обработки становится символом, например 'A', 'B' и т.д. Тогда sorted(indicators) будет сортировать по символам в алфавитном порядке.

Но в выводе сейчас отображается код как code, который после обработки в process_packet: code |= 0x40, затем symbol = chr(code). Возможно, коды символов отображаются как буквы.

Но это неважно для вывода — главное, чтобы вывод был структурирован.

Теперь придумаю, как оформить вывод. Например:

=======================
Current Indicators (Updated: 2025-06-19 12:34:56)
Code	Value	Time (sec)
A	123.45	2.3
B	-67.89	5.1
...		
Также можно добавить цвет для разных строк. Например, если время обновления больше 10 секунд, подсвечивать красным.

Но для цвета нужно использовать colorama. Добавлю импорт и инициализацию.

Также можно добавить прогресс-бар или индикатор активности, но это, возможно, излишне.

Теперь продумаю изменения в коде.

В функции update_display():

1.
Очистка экрана остается.
2.
Вывод заголовка с текущей датой и временем.
3.
Вывод разделителя.
4.
Заголовки колонок.
5.
Для каждого кода в sorted(indicators) выводим строку с выравниванием.
Для выравнивания можно использовать форматирование строк с фиксированной шириной. Например:

print(f"{code:^5} | {data['value']:^10.2f} | {elapsed:^10.1f}")

Но лучше использовать фиксированные ширины колонок, чтобы всё выравнивалось.

Также можно округлить значение value до 2 знаков после запятой.

Текущий код делит value на 1 или 16 в зависимости от symbol. Но в выводе используется data['value'], который уже обработан.

Теперь оформлю пример кода для update_display().

Импортирую colorama:

from colorama import Fore, Style, init

init() # Инициализация для Windows

В начале программы.

В функции update_display():

os.system('cls' if os.name == 'nt' else 'clear')

current_time = time.time()

print(f"{Fore.CYAN}=== Индикаторы (Обновлено: {time.strftime('%Y-%m-%d %H:%M:%S')}) ==={Style.RESET_ALL}\n")

print(f"{Fore.GREEN}Код | Значение | Время (сек){Style.RESET_ALL}")
print("-" * 40)

for code in sorted(indicators):
data = indicators[code]
elapsed = current_time - data['last_updated']
value = data['value']
# Форматирование строки с цветами
# Например, если elapsed > 10, то красный
if elapsed > 10:
color = Fore.RED
else:
color = Fore.WHITE
print(f"{color}{code:^6} | {value:^10.2f} | {elapsed:^10.1f}{Style.RESET_ALL}")

Но нужно учесть, что colorama требует сброса стиля после каждой строки, иначе цвет будет применяться ко всему выводу после.

Также можно добавить разные цвета для разных состояний.

Но если пользователь не хочет добавлять зависимости, то можно обойтись без colorama, используя только форматирование текста.

Тогда можно добавить разделители, выравнивание, возможно, символы-рамочки.

Например:

Очистка экрана.

Вывод заголовка:

print("="*50)
print(f"Current Time: {time.strftime('%Y-%m-%d %H:%M:%S')}")
print("="*50)

Затем заголовки колонок:

print(f"{'Code':<6} | {'Value':>10} | {'Time (sec)':>10}")
print("-" * 30)

Затем для каждого кода:

for code in sorted(indicators):
data = indicators[code]
elapsed = current_time - data['last_updated']
value = data['value']
print(f"{code:<6} | {value:>10.2f} | {elapsed:>10.1f}")

Такой вывод будет более структурированным.

Также можно добавить раздел статуса, например, количество активных индикаторов.

Ещё можно добавить анимацию, например, мигающую точку или что-то подобное, но это сложнее.

Поскольку задача — добавить красивый вывод, то, возможно, лучше использовать библиотеку rich, которая позволяет создавать таблицы и красивый вывод. Но если это невозможно, то ограничиться стандартными средствами.

Но в исходном коде нет импорта colorama или rich, значит, нужно либо добавить импорт, либо обойтись без него.

Предположу, что можно добавить colorama, так как это распространённая библиотека для цветного вывода.

Тогда модифицирую код:

В начале добавлю:

from colorama import Fore, Style, init
import time
import serial
import os

init() # Инициализация colorama

В функции update_display():

os.system('cls' if os.name == 'nt' else 'clear')

current_time = time.time()

Заголовок
print(f"\n{Fore.CYAN}╔{'='*50}╗{Style.RESET_ALL}")
print(f"{Fore.CYAN}║{Style.RESET_ALL} Индикаторы состояния {Fore.CYAN}║{Style.RESET_ALL}")
print(f"{Fore.CYAN}╠{'='*50}╣{Style.RESET_ALL}")
print(f"{Fore.CYAN}║{Style.RESET_ALL} Время обновления: {time.strftime('%Y-%m-%d %H:%M:%S')} {Fore.CYAN}║{Style.RESET_ALL}")
print(f"{Fore.CYAN}╚{'='*50}╝{Style.RESET_ALL}\n")

Заголовки таблицы
print(f"{Fore.GREEN}{'Код':<6} | {'Значение':>10} | {'Время (сек)':>10}{Style.RESET_ALL}")
print(f"{Fore.GREEN}{'-'*6} | {'-'*10} | {'-'*10}{Style.RESET_ALL}")

for code in sorted(indicators):
data = indicators[code]
elapsed = current_time - data['last_updated']
value = data['value']
# Выбор цвета в зависимости от времени
if elapsed > 10:
color = Fore.RED
elif elapsed > 5:
color = Fore.YELLOW
else:
color = Fore.WHITE
print(f"{color}{code:<6} | {value:>10.2f} | {elapsed:>10.1f}{Style.RESET_ALL}")

Такой вывод будет использовать цвета для разных строк в зависимости от времени с последнего обновления.

Также можно добавить разделители между секциями, рамки из символов.

Если же нельзя использовать colorama, то можно использовать только форматирование без цветов.

Но в задании не указано ограничение на использование библиотек, поэтому предположу, что можно добавить colorama.

Нужно также учесть, что в коде используется os.system('cls' или 'clear'), что может мигать при обновлении. Возможно, лучше использовать более плавное обновление, но это сложнее.

Также можно добавить прогресс-бар или другие элементы, но для начала сделаю базовый красивый вывод с цветами и таблицей.

Теперь проверю, что изменённый код функции update_display() будет выводить более красивые данные.

Также в текущем коде process_packet() может обновлять indicators, и update_display() вызывается в цикле.

Важно, чтобы изменения в update_display() не нарушали логику программы.

Теперь проверю, правильно ли обрабатываются значения. В process_packet() value делится на 1 или 16, в зависимости от symbol. Но symbol определяется как chr(code), где code |= 0x40. Возможно, это специфично для протокола, но в выводе это неважно.

В выводе нужно отображать value как есть, после всех преобразований.

Теперь внесу изменения в код:

Добавлю импорт colorama в начало:

from colorama import Fore, Style, init
init()

В функции update_display() заменю print на форматированные строки с цветами.

Также можно добавить счётчик обновлений или другие метрики.

Проверю, что код будет работать. Например, после очистки экрана выводится заголовок, затем таблица.

Теперь пример изменённой функции update_display():

def update_display():
"""Обновляет экран, выводя текущие показатели."""
os.system('cls' if os.name == 'nt' else 'clear') # Очистка экрана
current_time = time.time()

# Заголовок с цветом
print(f"\n{Fore.CYAN}╔{'═'*60}╗{Style.RESET_ALL}")
print(f"{Fore.CYAN}║{Style.RESET_ALL}   {Fore.GREEN}Система мониторинга показателей{Style.RESET_ALL}   {Fore.CYAN}║{Style.RESET_ALL}")
print(f"{Fore.CYAN}╠{'═'*60}╣{Style.RESET_ALL}")
print(f"{Fore.CYAN}║{Style.RESET_ALL}   Время обновления: {Fore.YELLOW}{time.strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}   {Fore.CYAN}║{Style.RESET_ALL}")
print(f"{Fore.CYAN}╚{'═'*60}╝{Style.RESET_ALL}\n")

# Заголовок таблицы
print(f"{Fore.GREEN}{'Код':<6} | {'Значение':>12} | {'Время (сек)':>12} | {'Статус':<10}{Style.RESET_ALL}")
print(f"{Fore.GREEN}{'-'*6} | {'-'*12} | {'-'*12} | {'-'*10}{Style.RESET_ALL}")

# Вывод данных
for code in sorted(indicators, key=lambda x: ord(x)):  # Сортировка по символу
    data = indicators[code]
    elapsed = current_time - data['last_updated']
    value = data['value']
    
    # Определение цвета на основе времени
    if elapsed > 10:
        time_color = Fore.RED
    elif elapsed > 5:
        time_color = Fore.YELLOW
    else:
        time_color = Fore.GREEN
    
    # Статус на основе времени
    status = "Устарел" if elapsed > 10 else "Обновлен"
    status_color = Fore.RED if elapsed > 10 else Fore.GREEN
    
    print(f"{Fore.WHITE}{code:<6} | {Fore.CYAN}{value:>12.2f} | {time_color}{elapsed:>12.1f} | {status_color}{status:<10}{Style.RESET_ALL}")
Такой вывод будет более красивым: заголовок с рамкой из символов, цветные колонки, статус.

Но нужно протестировать, чтобы цвета правильно сбрасывались после каждой строки, иначе цвета могут накладываться.

Также можно добавить больше деталей, например, разные цвета для разных кодов, но это усложнит код.

Ещё можно добавить общий статус системы внизу, например, количество активных индикаторов.

В итоге, после изменений, вывод должен быть структурированным, с цветами и понятными колонками.

Чтобы добавить красивый вывод в консоль, я модифицировал код с использованием библиотеки colorama для цветного текста и структурированного форматирования. 

# Основные улучшения:

1. Цветной заголовок с использованием символов-рамок
2. Табличное форматирование данных с выравниванием
3. Цветовая индикация статуса:
Зеленый - недавние данные (<5 сек)
Желтый - умеренная актуальность (5-10 сек)
Красный - устаревшие данные (>10 сек)
4. Четкое разделение секций с помощью цветных линий
5. Информативные колонки с автоматическим форматированием значений
